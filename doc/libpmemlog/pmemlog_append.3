.\" Automatically generated by Pandoc 2.0.6
.\"
.TH "PMEMLOG_APPEND" "3" "2021-09-24" "PMDK - pmemlog API version 1.1" "PMDK Programmer's Manual"
.hy
.\" SPDX-License-Identifier: BSD-3-Clause
.\" Copyright 2017-2018, Intel Corporation
.SH NAME
.PP
\f[B]pmemlog_append\f[](), \f[B]pmemlog_appendv\f[]() \- append bytes to
the persistent memory resident log file
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmemlog.h>

int\ pmemlog_append(PMEMlogpool\ *plp,\ const\ void\ *buf,\ size_t\ count);
int\ pmemlog_appendv(PMEMlogpool\ *plp,\ const\ struct\ iovec\ *iov,\ int\ iovcnt);
\f[]
.fi
.SH DESCRIPTION
.PP
The \f[B]pmemlog_append\f[]() function appends \f[I]count\f[] bytes from
\f[I]buf\f[] to the current write offset in the log memory pool
\f[I]plp\f[].
Calling this function is analogous to appending to a file.
The append is atomic and cannot be torn by a program failure or system
crash.
.PP
The \f[B]pmemlog_appendv\f[]() function appends to the log memory pool
\f[I]plp\f[] from the scatter/gather list \f[I]iov\f[] in a manner
similar to \f[B]writev\f[](2).
The entire list of buffers is appended atomically, as if the buffers in
\f[I]iov\f[] were concatenated in order.
The append is atomic and cannot be torn by a program failure or system
crash.
.SH RETURN VALUE
.PP
On success, \f[B]pmemlog_append\f[]() and \f[B]pmemlog_appendv\f[]()
return 0.
On error, they return \-1 and set \f[I]errno\f[] appropriately.
.SH ERRORS
.PP
\f[B]EINVAL\f[] The vector count \f[I]iovcnt\f[] is less than zero.
.PP
\f[B]ENOSPC\f[] There is no room for the data in the log file.
.PP
\f[B]EROFS\f[] The log file is open in read\-only mode.
.SH NOTES
.PP
Since \f[B]libpmemlog\f[](7) is designed as a low\-latency code path,
many of the checks routinely done by the operating system for
\f[B]writev\f[](2) are not practical in the library's implementation of
\f[B]pmemlog_appendv\f[]().
No attempt is made to detect NULL or incorrect pointers, for example.
.SH SEE ALSO
.PP
\f[B]writev\f[](2), \f[B]libpmemlog\f[](7) and
\f[B]<https://pmem.io>\f[]
