.\" Automatically generated by Pandoc 2.0.6
.\"
.TH "PMEM2_DEEP_FLUSH" "3" "2021-09-24" "PMDK - pmem2 API version 1.0" "PMDK Programmer's Manual"
.hy
.\" SPDX-License-Identifier: BSD-3-Clause
.\" Copyright 2020, Intel Corporation
.SH NAME
.PP
\f[B]pmem2_deep_flush\f[]() \- highly reliable persistent memory
synchronization
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmem2.h>

int\ pmem2_deep_flush(struct\ pmem2_map\ *map,\ void\ *ptr,\ size_t\ size)
\f[]
.fi
.SH DESCRIPTION
.PP
The \f[B]pmem2_deep_flush\f[]() function forces any changes in the range
[\f[I]ptr\f[], \f[I]ptr\f[]+\f[I]len\f[]) from the \f[I]map\f[] to be
stored durably in the most reliable persistence domain available to
software.
In particular, on supported platforms, this enables the code not to rely
on automatic cache or WPQ (write pending queue) flush on power failure
(ADR/eADR).
.PP
Since this operation is usually much more expensive than regular
persist, it should be used sparingly.
Typically, the application should only ever use this function as a
precaution against hardware failures, e.g., in code that detects silent
data corruption caused by unsafe shutdown (see more in
\f[B]libpmem2_unsafe_shutdown\f[](7)).
.SH RETURN VALUE
.PP
The \f[B]pmem2_deep_flush\f[]() function returns 0 on success or an
error code on failure.
.SH ERRORS
.PP
The \f[B]pmem2_deep_flush\f[]() can fail with the following errors:
.IP \[bu] 2
\f[B]PMEM2_E_DEEP_FLUSH_RANGE\f[] \- the provided flush range is not a
subset of the map's address space.
.IP \[bu] 2
\f[B]PMEM2_E_DAX_REGION_NOT_FOUND\f[] \- the underlying device region id
cannot be detected.
.IP \[bu] 2
\-\f[B]errno\f[] set by failing \f[B]msync\f[](2), while trying to
perform a deep flush on a regular DAX volume.
.SH SEE ALSO
.PP
\f[B]msync\f[](2), \f[B]pmem2_get_drain_fn\f[](3),
\f[B]pmem2_get_persist_fn\f[](3) \f[B]pmem2_map\f[](3),
\f[B]libpmem2\f[](7) and \f[B]<http://pmem.io>\f[]
