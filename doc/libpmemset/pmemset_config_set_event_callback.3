.\" Automatically generated by Pandoc 2.0.6
.\"
.TH "pmemset_config_set_event_callback" "3" "2021-09-24" "PMDK - pmemset API version 1.0" "PMDK Programmer's Manual"
.hy
.\" SPDX-License-Identifier: BSD-3-Clause
.\" Copyright 2021, Intel Corporation
.SH NAME
.PP
\f[B]pmemset_config_set_event_callback\f[]() \- set an event callback
.SH SYNOPSIS
.IP
.nf
\f[C]
#include\ <libpmemset.h>
#define\ PMEMSET_EVENT_CONTEXT_SIZE\ (64)
struct\ pmemset_event_context\ {
\ \ \ \ enum\ pmemset_event\ type;
\ \ \ \ union\ {
\ \ \ \ \ \ \ \ char\ _data[PMEMSET_EVENT_CONTEXT_SIZE];
\ \ \ \ \ \ \ \ struct\ pmemset_event_copy\ copy;
\ \ \ \ \ \ \ \ struct\ pmemset_event_move\ move;
\ \ \ \ \ \ \ \ struct\ pmemset_event_set\ set;
\ \ \ \ \ \ \ \ struct\ pmemset_event_flush\ flush;
\ \ \ \ \ \ \ \ struct\ pmemset_event_drain\ drain;
\ \ \ \ \ \ \ \ struct\ pmemset_event_persist\ persist;
\ \ \ \ \ \ \ \ struct\ pmemset_event_bad_block\ bad_block;
\ \ \ \ \ \ \ \ struct\ pmemset_event_part_remove\ part_remove;
\ \ \ \ \ \ \ \ struct\ pmemset_event_part_add\ part_add;
\ \ \ \ }\ data;
};

typedef\ int\ pmemset_event_callback(struct\ pmemset\ *set,
\ \ \ \ \ \ \ \ struct\ pmemset_event_context\ *ctx,
\ \ \ \ \ \ \ \ void\ *arg);

void\ pmemset_config_set_event_callback(struct\ pmemset_config\ *cfg,
\ \ \ \ \ \ \ \ pmemset_event_callback\ *callback,\ void\ *arg);
\f[]
.fi
.SH DESCRIPTION
.PP
The \f[B]pmemset_config_set_event_callback\f[]() sets an user provided
\f[I]callback\f[] in \f[I]cfg\f[].
\f[I]arg\f[] will be passed to the \f[I]callback\f[] each time it will
be called by the library.
.PP
The callback will be called by \f[I]pmemset\f[] each time an event
occurs.
Events are only fired during the user's calls of the
\f[B]libpmemset\f[](7) methods.
The detailed list of events and its description can be found in
\f[I]Events\f[] section below.
The \f[I]callback\f[] function should return 0 in case of success.
If the event supports error handling, the \f[I]callback\f[] can return a
non\-zero value in case of error, otherwise return value is ignored.
Struct \f[I]pmemset_event_context\f[] is a tagged union, which contains
all event structures, in \f[B]libpmemset\f[](7).
The \f[I]type\f[] field contains information of the type of the event
fired, where the data union contains event\-specific information.
.PP
There's no guarantee that accessing pointers in \f[I]ctx\f[] inside of
the callback is thread\-safe.
The library user must guarantee this by not having multiple threads
accessing the same region on the set.
Once the function exits \f[I]ctx\f[] and its data are invalid.
.SH RETURN VALUE
.PP
The \f[B]pmemset_config_set_event_callback\f[]() returns no value.
.SH EVENTS
.IP \[bu] 2
\f[B]PMEMSET_EVENT_PART_ADD\f[] \- occurs for each new part added to the
pmemset using \f[B]pmemset_part_map\f[](3) function.
.IP
.nf
\f[C]
struct\ pmemset_event_flush\ {
\ \ \ \ void\ *addr;
\ \ \ \ size_t\ len;
};
\f[]
.fi
.PP
\f[B]PMEMSET_EVENT_FLUSH\f[] is fired before \f[B]pmemset_flush\f[](3)
or \f[B]pmemset_persist\f[](3) completes its work.
The \f[I]flush\f[] field in \f[I]data\f[] union contains \f[I]addr\f[]
and \f[I]len\f[] passed to those functions.
This event doesn't support error handling, which means that the value
returned by the \f[I]callback\f[] function is ignored.
.PP
\f[B]PMEMSET_EVENT_DRAIN\f[] is fired after \f[B]pmemset_drain\f[](3) or
\f[B]pmemset_persist\f[](3) completes its work.
In case of \f[B]pmemset_persist\f[](3) this event is fired after
\f[B]PMEMSET_EVENT_FLUSH\f[].
This event doesn't support error handling, which means that the value
returned by the \f[I]callback\f[] function is ignored.
.IP
.nf
\f[C]
struct\ pmemset_event_copy\ {
\ \ \ \ void\ *src;
\ \ \ \ void\ *dest;
\ \ \ \ size_t\ len;
\ \ \ \ unsigned\ flags;
};

struct\ pmemset_event_move\ {
\ \ \ \ void\ *src;
\ \ \ \ void\ *dest;
\ \ \ \ size_t\ len;
\ \ \ \ unsigned\ flags;
};

struct\ pmemset_event_set\ {
\ \ \ \ void\ *dest;
\ \ \ \ int\ value;
\ \ \ \ size_t\ len;
\ \ \ \ unsigned\ flags;
};
\f[]
.fi
.PP
\f[B]PMEMSET_EVENT_COPY\f[], \f[B]PMEMSET_EVENT_MOVE\f[],
\f[B]PMEMSET_EVENT_SET\f[] are fired, respectively, before
\f[B]pmemset_memcpy\f[](3), \f[B]pmemset_memmove\f[](3),
\f[B]pmemset_memset\f[](3) completed its work.
Similarly, \f[I]copy\f[], \f[I]move\f[], or \f[I]set\f[] fields in the
\f[I]data\f[] union contain all arguments passed to these functions.
If \f[B]PMEMSET_F_MEM_NODRAIN\f[] flag is \f[B]not\f[] passed to these
functions, a single \f[B]PMEMSET_EVENT_DRAIN\f[] will be fired on the
end of opperation.
During these functions \[lq]flush\[rq] and \[lq]drain\[rq] operations
are performed, but they will not trigger any additional events.
\f[B]PMEMSET_EVENT_FLUSH\f[] and \f[B]PMEMSET_EVENT_DRAIN\f[] This event
doesn't support error handling, which means that the value returned by
the \f[I]callback\f[] function is ignored.
.SH SEE ALSO
.PP
\f[B]pmemset_part_map\f[], \f[B]libpmem2\f[](7), \f[B]libpmemset\f[](7)
and \f[B]<http://pmem.io>\f[]
